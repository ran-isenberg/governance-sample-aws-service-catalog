{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#aws-lambda-handler-cookbook-a-serverless-service-template","title":"AWS Lambda Handler Cookbook - A Serverless Service Template","text":""},{"location":"#the-problem","title":"The Problem","text":"<p>Starting a Serverless service can be overwhelming. You need to figure out many questions and challenges that have nothing to do with your business domain:</p> <ul> <li>How to deploy to the cloud? What IAC framework do you choose?</li> <li>How to write a SaaS-oriented CI/CD pipeline? What does it need to contain?</li> <li>How do you handle observability, logging, tracing, metrics?</li> <li>How do you handle testing?</li> </ul>"},{"location":"#the-solution","title":"The Solution","text":"<p>This project aims to reduce cognitive load and answer these questions for you by providing a skeleton Python Serverless service template that implements best practices for AWS Lambda, Serverless CI/CD, and AWS CDK in one template project.</p>"},{"location":"#serverless-service-the-order-service","title":"Serverless Service - The Order service","text":"<ul> <li> <p>This project provides a working orders service where customers can create orders of items.</p> </li> <li> <p>The project deploys an API GW with an AWS Lambda integration under the path POST /api/orders/ and stores orders data in a DynamoDB table.</p> </li> </ul>"},{"location":"#monitoring-design","title":"Monitoring Design","text":""},{"location":"#concepts","title":"Concepts","text":"<p>I spoke at AWS re:invent 2023 with Heitor Lessa, Chief Architect of Powertools for AWS Lambda about the concepts I implemented in this project.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Python Serverless service with a recommended file structure.</li> <li>CDK infrastructure with infrastructure tests and security tests.</li> <li>CI/CD pipelines based on Github actions that deploys to AWS with python linters, complexity checks and style formatters.</li> <li>CI/CD pipeline deploys to dev/staging and production environment with different gates between each environment</li> <li>Makefile for simple developer experience.</li> <li>The AWS Lambda handler embodies Serverless best practices and has all the bells and whistles for a proper production ready handler.</li> <li>AWS Lambda handler uses AWS Lambda Powertools.</li> <li>AWS Lambda handler 3 layer architecture: handler layer, logic layer and data access layer</li> <li>Features flags and configuration based on AWS AppConfig</li> <li>CloudWatch dashboards - High level and low level including CloudWatch alarms</li> <li>Idempotent API</li> <li>REST API protected by WAF with four AWS managed rules in production deployment</li> <li>Unit, infrastructure, security, integration and E2E tests.</li> <li>Automatically generated OpenAPI endpoint: /swagger with Pydantic schemas for both requests and responses</li> <li>Automated protection against API breaking changes</li> </ul> <p>The GitHub template project can be found at https://github.com/ran-isenberg/aws-lambda-handler-cookbook.</p>"},{"location":"#serverless-best-practices","title":"Serverless Best Practices","text":"<p>The AWS Lambda handler will implement multiple best practice utilities.</p> <p>Each utility is implemented when a new blog post is published about that utility.</p> <p>The utilities cover multiple aspects of a production-ready service, including:</p> <ul> <li>Logging</li> <li>Observability: Monitoring and Tracing</li> <li>Observability: Business KPI Metrics</li> <li>Environment Variables</li> <li>Input Validation</li> <li>Dynamic configuration &amp; features flags</li> <li>Serverless Monitoring</li> <li>API Idempotency</li> <li>Learn How to Write AWS Lambda Functions with Three Architecture Layers</li> <li>Serverless OpenAPI Documentation with AWS Powertools</li> </ul> <p>While the code examples are written in Python, the principles are valid to any supported AWS Lambda handler programming language.</p>"},{"location":"#license","title":"License","text":"<p>This library is licensed under the MIT License. See the LICENSE file.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker - install Docker. Required for the Lambda layer packaging process.</li> <li>AWS CDK - Required for synth &amp; deploying the AWS Cloudformation stack. Run CDK Bootstrap on your AWS account and region.</li> <li>Python 3.11</li> <li>poetry - Make sure to run <code>poetry config --local virtualenvs.in-project true</code> so all dependencies are installed in the project '.venv' folder.</li> <li>For Windows based machines, use the Makefile_windows version (rename to Makefile). Default Makefile is for Mac/Linux.</li> </ul>"},{"location":"getting_started/#getting-started","title":"Getting Started","text":"<p>You can start with a clean service out of this template repository without using the 'Template' button on GitHub.</p> <p>You can use Cookiecutter.</p> <ul> <li>Cookiecutter - install with pip/brew <code>brew install cookiecutter</code> or <code>`pip install cookiecutter</code></li> </ul> <p>Then run:</p> <p><code>cookiecutter gh:ran-isenberg/cookiecutter-serverless-python</code></p> <p>Answer the questions to select repo name, service name, etc.:</p> <p></p> <p>That's it, your developer environment has been set! you are ready to deploy the service:</p>"},{"location":"getting_started/#creating-a-developer-environment-without-cookiecutter","title":"Creating a Developer Environment (without cookiecutter)","text":"<ol> <li>Run <code>make dev</code></li> </ol>"},{"location":"getting_started/#deploy-cdk","title":"Deploy CDK","text":"<p>Create a cloudformation stack by running <code>make deploy</code>.</p>"},{"location":"getting_started/#unit-tests","title":"Unit Tests","text":"<p>Unit tests can be found under the <code>tests/unit</code> folder.</p> <p>You can run the tests by using the following command: <code>make unit</code>.</p>"},{"location":"getting_started/#integration-tests","title":"Integration Tests","text":"<p>Make sure you deploy the stack first as these tests trigger your lambda handler LOCALLY but they can communicate with AWS services.</p> <p>These tests allow you to debug in your IDE your AWS Lambda function.</p> <p>Integration tests can be found under the <code>tests/integration</code> folder.</p> <p>You can run the tests by using the following command: <code>make integration</code>.</p>"},{"location":"getting_started/#e2e-tests","title":"E2E Tests","text":"<p>Make sure you deploy the stack first.</p> <p>E2E tests can be found under the <code>tests/e2e</code> folder.</p> <p>These tests send a 'POST' message to the deployed API GW and trigger the Lambda function on AWS.</p> <p>The tests are run automatically by: <code>make e2e</code>.</p>"},{"location":"getting_started/#deleting-the-stack","title":"Deleting the stack","text":"<p>CDK destroy can be run with <code>make destroy</code>.</p>"},{"location":"getting_started/#preparing-code-for-pr","title":"Preparing Code for PR","text":"<p>Run <code>make pr</code>. This command will run all the required checks, pre commit hooks, linters, code formatters, import sorting and tests, so you can be sure GitHub's pipeline will pass. It will also generate an updated swagger OpenAPI JSON file and place it at docs/swagger/openapi.json location.</p> <p>The command auto fixes errors in the code for you.</p> <p>If there's an error in the pre-commit stage, it gets auto fixed. However, are required to run <code>make pr</code> again so it continues to the next stages.</p> <p>Be sure to commit all the changes that <code>make pr</code> does for you.</p>"},{"location":"getting_started/#openapi-swagger-generation","title":"OpenAPI Swagger Generation","text":"<p>Run either <code>make pr</code> or <code>make openopi</code> to generate an updated swagger OpenAPI JSON file and place it at docs/swagger/openapi.json location.</p>"},{"location":"getting_started/#github-pages-documentation","title":"GitHub Pages Documentation","text":"<p><code>make docs</code> can be run to start a local HTTP server with the project's documentation pages.</p>"},{"location":"getting_started/#building-devlambda_requirementstxt","title":"Building dev/lambda_requirements.txt","text":""},{"location":"getting_started/#lambda_requirementstxt","title":"lambda_requirements.txt","text":"<p>CDK requires a requirements.txt in order to create a zip file with the Lambda layer dependencies. It's based on the project's poetry.lock file.</p> <p><code>make deploy</code> command will generate it automatically for you.</p>"},{"location":"getting_started/#dev_requirementstxt","title":"dev_requirements.txt","text":"<p>This file is used during GitHub CI to install all the required Python libraries without using poetry.</p> <p>File contents are created out of the Pipfile.lock.</p> <p><code>make deploy</code> and <code>make deps</code> are commands generate it automatically.</p>"}]}